/**
 * @file partition_table.c
 * @author TheSomeMan
 * @date 2023-05-11
 * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause.
 */

#include "partition_table.h"
#include <stdint.h>
#include <string.h>
#include <esp_spi_flash.h>
#include "os_malloc.h"

#define LOG_LOCAL_LEVEL LOG_LEVEL_INFO
#include "log.h"
#include "reset_task.h"

static const char TAG[] = "partition_table";

bool
partition_table_check_and_update(void)
{
    const uint32_t       partition_table_address = 0x8000;
    static const uint8_t g_partition_table[]     = {
            0xAA, 0x50, 0x01, 0x02, 0x00, 0x90, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x6E, 0x76, 0x73, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x50, 0x01, 0x00,
            0x00, 0xD0, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x6F, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x50, 0x01, 0x01, 0x00, 0xF0, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00, 0x70, 0x68, 0x79, 0x5F, 0x69, 0x6E, 0x69, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x50, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x40, 0x00,
            0x6F, 0x74, 0x61, 0x5F, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xAA, 0x50, 0x01, 0x81, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x66, 0x61, 0x74, 0x66,
            0x73, 0x5F, 0x67, 0x77, 0x75, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x50,
            0x01, 0x81, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x66, 0x61, 0x74, 0x66, 0x73, 0x5F, 0x6E, 0x72,
            0x66, 0x35, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x50, 0x00, 0x11, 0x00, 0x00,
            0x60, 0x00, 0x00, 0x00, 0x40, 0x00, 0x6F, 0x74, 0x61, 0x5F, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x50, 0x01, 0x81, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00,
            0x0C, 0x00, 0x66, 0x61, 0x74, 0x66, 0x73, 0x5F, 0x67, 0x77, 0x75, 0x69, 0x5F, 0x32, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xAA, 0x50, 0x01, 0x81, 0x00, 0x00, 0xAC, 0x00, 0x00, 0x00, 0x04, 0x00, 0x66, 0x61,
            0x74, 0x66, 0x73, 0x5F, 0x6E, 0x72, 0x66, 0x35, 0x32, 0x5F, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xAA, 0x50, 0x01, 0x02, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0x04, 0x00, 0x67, 0x77, 0x5F, 0x63, 0x66, 0x67,
            0x5F, 0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEB, 0xEB, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0xD2, 0x3B, 0x43, 0x8E, 0xDF,
            0xCD, 0x47, 0xFF, 0x8D, 0xC2, 0xA0, 0xCB, 0x86, 0x46, 0x7B,
    };
    bool flag_partition_updated = false;
    LOG_INFO("#### Check partition table");
    uint8_t* p_buf = os_malloc(SPI_FLASH_SEC_SIZE);
    if (NULL == p_buf)
    {
        LOG_ERR("Can't allocate memory");
        return false;
    }

    esp_err_t err = spi_flash_read(partition_table_address, p_buf, SPI_FLASH_SEC_SIZE);
    if (ESP_OK != err)
    {
        LOG_ERR_ESP(err, "%s failed", "esp_flash_read");
        return false;
    }
    if (0 != memcmp(g_partition_table, p_buf, sizeof(g_partition_table)))
    {
        LOG_WARN("Partition table do not match - need to update");
        err = spi_flash_erase_range(partition_table_address, SPI_FLASH_SEC_SIZE);
        if (ESP_OK != err)
        {
            LOG_ERR_ESP(err, "%s failed", "esp_flash_erase_region");
            return false;
        }
        err = spi_flash_write(partition_table_address, g_partition_table, sizeof(g_partition_table));
        if (ESP_OK != err)
        {
            LOG_ERR_ESP(err, "%s failed", "esp_flash_read");
            return false;
        }
        LOG_INFO("#### Partition table has been successfully updated");
        // reboot required
        flag_partition_updated = true;
    }
    os_free(p_buf);
    return flag_partition_updated;
}
